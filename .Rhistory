metadata     = meta_i,
exist        = exist_i,
comparison   = name,
library_meta = lib_metadata_df
),
envir = new.env()
)
render(
input          = template,
output_file    = paste0(name, ".html"),
params = list(
metadata     = meta_i,
exist        = exist_i,
comparison   = name,
library_meta = lib_metadata_df
),
envir = new.env()
)
render(
input          = template,
output_file    = paste0(name, ".html"),
params = list(
metadata     = meta_i,
exist        = exist_i,
comparison   = name,
library_meta = lib_metadata_df
),
envir = new.env()
)
render(
input          = template,
output_file    = paste0(name, ".html"),
params = list(
metadata     = meta_i,
exist        = exist_i,
comparison   = name,
library_meta = lib_metadata_df
),
envir = new.env()
)
meta_i
samples
samples$timepoint
factor(samples$timepoint)
samples
# Set a palette of up to 12 distinct colors
available_colors <- c(
"#1b9e77", "#d95f02", "#7570b3", "#e7298a",
"#66a61e", "bisque1", "#a6761d", "#666666",
"#a6cee3", "#1f78b4", "#b2df8a", "salmon2")
i <- 2
# Color map to remember assignments
group_color_map <- list()
i <- 2
comp <- comparisons[i, ]
name <- pull(comp[1])
g1   <- pull(comp[2])
g2   <- pull(comp[3])
groups <- c(g1, g2)
for (g in groups) {
if (!g %in% names(group_color_map)) {
used_colors <- unlist(group_color_map)
available <- setdiff(available_colors, used_colors)
if (length(available) == 0) {
warning("Ran out of distinct colors, reusing colors!!! Add more :)")
available <- available_colors
}
group_color_map[[g]] <- available[1]
}
custom_colors <- setNames(unlist(group_color_map[groups]), groups)
custom_colors
# pull out just those samples that belong to g1 or g2
meta_i <- samples %>%
filter( .data[[g1]] == 1 | .data[[g2]] == 1 ) %>%
transmute(
SampleName,
group_test = if_else(.data[[g1]] == 1, g1, g2),
!!!extra_syms
) %>%
mutate(
# force the factor levels so g1 is first, g2 second
group_test = factor(group_test, levels = c(g1, g2))
)
# filter your existence matrix to just those SampleName
exist_i <- exist %>%
select(any_of(meta_i$SampleName))
# render directly, passing the objects
render(
input          = template,
output_file    = paste0(name, ".html"),
params = list(
metadata     = meta_i,
exist        = exist_i,
comparison   = name,
library_meta = lib_metadata_df,
custom_colors = custom_colors
),
envir = new.env()
)
group_color_map
i <- 1
comp <- comparisons[i, ]
name <- pull(comp[1])
g1   <- pull(comp[2])
g2   <- pull(comp[3])
groups <- c(g1, g2)
for (g in groups) {
if (!g %in% names(group_color_map)) {
used_colors <- unlist(group_color_map)
available <- setdiff(available_colors, used_colors)
if (length(available) == 0) {
warning("Ran out of distinct colors, reusing colors!!! Add more :)")
available <- available_colors
}
group_color_map[[g]] <- available[1]
}
custom_colors <- setNames(unlist(group_color_map[groups]), groups)
group_color_map
custom_colors
# pull out just those samples that belong to g1 or g2
meta_i <- samples %>%
filter( .data[[g1]] == 1 | .data[[g2]] == 1 ) %>%
transmute(
SampleName,
group_test = if_else(.data[[g1]] == 1, g1, g2),
!!!extra_syms
) %>%
mutate(
# force the factor levels so g1 is first, g2 second
group_test = factor(group_test, levels = c(g1, g2))
)
# filter your existence matrix to just those SampleName
exist_i <- exist %>%
select(any_of(meta_i$SampleName))
# render directly, passing the objects
render(
input          = template,
output_file    = paste0(name, ".html"),
params = list(
metadata     = meta_i,
exist        = exist_i,
comparison   = name,
library_meta = lib_metadata_df,
custom_colors = custom_colors
),
envir = new.env()
)
group_cols <- c("group_test")
features_target <- as.data.frame(t(exist_i)) %>%
tibble::rownames_to_column("SampleName")%>%
dplyr::left_join(meta_o %>% select(any_of(c("SampleName", group_cols))), by = "SampleName")
features_target <- as.data.frame(t(exist_i)) %>%
tibble::rownames_to_column("SampleName")%>%
dplyr::left_join(meta_i %>% select(any_of(c("SampleName", group_cols))), by = "SampleName")
features_target
group_cols
group_col <- "group_test"
group_col
# Full matrix sames as exist for the corresponding group and transposed
binary_data_all <- features_target %>%
select(-any_of(group_col)) %>%
column_to_rownames("SampleName")
features_target %>%
select(-any_of(group_col))
features_target %>%
dplyr::select(-any_of(group_col)) %>%
tibble::column_to_rownames("SampleName")
cmp_file    <- "Metadata/comparisons.csv"#args[1]
samples_file<- "Metadata/sorted_LLNEXT_samples_binary.csv"#args[2]
exist_file  <- "Data/exist.csv"#args[3]
library_meta <- "Metadata/all_libraries_with_important_info.rds" # args[4]
template    <- "template.Rmd"#args[5]
# read inputs
comparisons <- read_csv(cmp_file)
samples     <- read_csv(samples_file) %>%
rename_with(~ "SampleName", .cols = 1)
exist       <- read.csv(exist_file, header = TRUE, row.names = 1, check.names = FALSE,
stringsAsFactors = FALSE)
extra_cols <- character()
extra_syms <- syms(extra_cols)
lib_metadata_df <- readRDS(library_meta)
# Set a palette of up to 12 distinct colors
available_colors <- c(
"#1b9e77", "#d95f02", "#7570b3", "#e7298a",
"#66a61e", "bisque1", "#a6761d", "#666666",
"#a6cee3", "#1f78b4", "#b2df8a", "salmon2")
# Color map to remember assignments
group_color_map <- list()
i <- 1
comp <- comparisons[i, ]
name <- pull(comp[1])
g1   <- pull(comp[2])
g2   <- pull(comp[3])
groups <- c(g1, g2)
for (g in groups) {
if (!g %in% names(group_color_map)) {
used_colors <- unlist(group_color_map)
available <- setdiff(available_colors, used_colors)
if (length(available) == 0) {
warning("Ran out of distinct colors, reusing colors!!! Add more :)")
available <- available_colors
}
group_color_map[[g]] <- available[1]
}
custom_colors <- setNames(unlist(group_color_map[groups]), groups)
# pull out just those samples that belong to g1 or g2
meta_i <- samples %>%
filter( .data[[g1]] == 1 | .data[[g2]] == 1 ) %>%
transmute(
SampleName,
group_test = if_else(.data[[g1]] == 1, g1, g2),
!!!extra_syms
) %>%
mutate(
# force the factor levels so g1 is first, g2 second
group_test = factor(group_test, levels = c(g1, g2))
)
# filter your existence matrix to just those SampleName
exist_i <- exist %>%
select(any_of(meta_i$SampleName))
# render directly, passing the objects
render(
input          = template,
output_file    = paste0(name, ".html"),
params = list(
metadata     = meta_i,
exist        = exist_i,
comparison   = name,
library_meta = lib_metadata_df,
custom_colors = custom_colors
),
envir = new.env()
)
i <- 2
comp <- comparisons[i, ]
name <- pull(comp[1])
g1   <- pull(comp[2])
g2   <- pull(comp[3])
groups <- c(g1, g2)
for (g in groups) {
if (!g %in% names(group_color_map)) {
used_colors <- unlist(group_color_map)
available <- setdiff(available_colors, used_colors)
if (length(available) == 0) {
warning("Ran out of distinct colors, reusing colors!!! Add more :)")
available <- available_colors
}
group_color_map[[g]] <- available[1]
}
custom_colors <- setNames(unlist(group_color_map[groups]), groups)
# pull out just those samples that belong to g1 or g2
meta_i <- samples %>%
filter( .data[[g1]] == 1 | .data[[g2]] == 1 ) %>%
transmute(
SampleName,
group_test = if_else(.data[[g1]] == 1, g1, g2),
!!!extra_syms
) %>%
mutate(
# force the factor levels so g1 is first, g2 second
group_test = factor(group_test, levels = c(g1, g2))
)
# filter your existence matrix to just those SampleName
exist_i <- exist %>%
select(any_of(meta_i$SampleName))
# render directly, passing the objects
render(
input          = template,
output_file    = paste0(name, ".html"),
params = list(
metadata     = meta_i,
exist        = exist_i,
comparison   = name,
library_meta = lib_metadata_df,
custom_colors = custom_colors
),
envir = new.env()
)
library(stringr)
samples
# STEP 1: Extract individual ID from SampleName
samples <- samples %>%
mutate(
generic_ind_id = str_extract(SampleName, "\\d{6}")  # captures the 000145 part
)
samples
# STEP 2: Gather group assignments into long format
group_cols <- c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12")
long_df <- samples %>%
pivot_longer(cols = all_of(group_cols), names_to = "group", values_to = "in_group") %>%
filter(in_group == 1) %>%
select(generic_ind_id, group, SampleName)
long_df
samples
# STEP 3: Pivot back to wide format
wide_df <- long_df %>%
pivot_wider(names_from = group, values_from = SampleName)
wide_df
long_df
# STEP 3: Pivot back to wide format
wide_df <- long_df %>%
pivot_wider(names_from = group, values_from = SampleName)
long_df %>%
count(generic_ind_id, group) %>%
filter(n > 1)
samples <- samples %>%
mutate(
accession   = str_extract(SampleName, "\\d{6}"),                # "005258"
replicate   = str_extract(SampleName, "(?<=\\d{6}_)\\d+(?=-)")  # "2" or NA
)
# long_df <- samples %>%
#   pivot_longer(cols = all_of(group_cols), names_to = "group", values_to = "in_group") %>%
#   filter(in_group == 1) %>%
#   select(generic_ind_id, group, SampleName)
long_df <- samples %>%
pivot_longer(all_of(group_cols),
names_to  = "group",
values_to = "in_group") %>%
filter(in_group == 1) %>%
select(accession, replicate, group, SampleName)
long_df
long_df %>%
count(generic_ind_id, group) %>%
filter(n > 1)
long_df %>%
count(accession, replicates, group) %>%
filter(n > 1)
long_df %>%
count(accession, replicate, group) %>%
filter(n > 1)
wide_df <- long_df %>%
pivot_wider(
id_cols      = c(accession, replicate),
names_from   = group,
values_from  = SampleName
)
wide_df
print(wide_df)
print(as.data.frame(wide_df))
wide_df %>%
select(accesion == "304268")
wide_df
wide_df %>%
select(accession == "304268")
wide_df %>%
filter(accession == "304268")
write.csv(wide_df, "LLNext_ind_timepoints", quote = FALSE, col.names = T)
write.csv(wide_df, "LLNext_ind_timepoints", quote = FALSE, col.names = TRUE)
write.csv(wide_df, "LLNext_ind_timepoints.csv", quote = FALSE)
wide_df %>%
filter(accession == "304268")
wide_df %>%
filter(accession == "005258")
# Extract individual ID from SampleName
samples <- samples %>%
mutate(
accession   = str_extract(SampleName, "\\d{6}"),                # "005258"
replicate   = str_extract(SampleName, "(?<=\\d{6}_)\\d+(?=-)")  # "2" or NA
)
# Extract individual ID from SampleName
samples <- samples %>%
mutate(
accession   = str_extract(SampleName, "\\d{6}_?")                # "005258"
#replicate   = str_extract(SampleName, "(?<=\\d{6}_)\\d+(?=-)")  # "2" or NA
)
samples
samples$generic_ind_id
samples     <- read_csv(samples_file) %>%
rename_with(~ "SampleName", .cols = 1)
# Extract individual ID from SampleName
samples_with_ids <- samples %>%
mutate(
accession   = str_extract(SampleName, "\\d{6}_?"),                # "005258"
replicate   = str_extract(SampleName, "(?<=\\d{6}_)\\d+(?=-)")  # "2" or NA
)
# Gather group assignments into long format
group_cols <- c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12")
# Gather group assignments into long format
group_cols <- factor(c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12"))
group_cols
# Gather group assignments into long format
group_cols <- factor(c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12"), ordered = T)
group_cols
# Gather group assignments into long format
group_cols <- factor(c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12"), ordered = F)
group_cols
# Gather group assignments into long format
group_cols <- factor(c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12"),
levels = c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12"))
group_cols
long_df <- samples_with_ids %>%
pivot_longer(all_of(group_cols),
names_to  = "group",
values_to = "in_group") %>%
filter(in_group == 1) %>%
select(accession, replicate, group, SampleName)
wide_df <- long_df %>%
pivot_wider(
id_cols      = c(accession, replicate),
names_from   = group,
values_from  = SampleName
)
wide_df
wide_df <- long_df %>%
pivot_wider(
id_cols      = c(accession, replicate),
names_from   = group,
values_from  = SampleName
) %>%
sort(accession)
wide_df <- long_df %>%
pivot_wider(
id_cols      = c(accession, replicate),
names_from   = group,
values_from  = SampleName
) %>%
sort(wide_df$accession  )
wide_df <- long_df %>%
pivot_wider(
id_cols      = c(accession, replicate),
names_from   = group,
values_from  = SampleName
) %>%
sort(wide_df$accession)
wide_df$accession
wide_df <- long_df %>%
pivot_wider(
id_cols      = c(accession, replicate),
names_from   = group,
values_from  = SampleName
) %>%
sort(as.integer(wide_df$accession))
as.integer(wide_df$accession)
sort(wide_df$accession
wide_df <- long_df %>%
pivot_wider(
id_cols      = c(accession, replicate),
names_from   = group,
values_from  = SampleName
) %>%
sort(wide_df$accession)
wide_df$accession
# Extract individual ID from SampleName
samples_with_ids <- samples %>%
mutate(
accession   = str_extract(SampleName, "\\d{6}_?\\d?"),                # "005258"
replicate   = str_extract(SampleName, "(?<=\\d{6}_)\\d+(?=-)")  # "2" or NA
)
# Gather group assignments into long format
group_cols <- factor(c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12"),
levels = c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12"))
long_df <- samples_with_ids %>%
pivot_longer(all_of(group_cols),
names_to  = "group",
values_to = "in_group") %>%
filter(in_group == 1) %>%
select(accession, replicate, group, SampleName)
wide_df <- long_df %>%
pivot_wider(
id_cols      = c(accession, replicate),
names_from   = group,
values_from  = SampleName
) %>%
sort(wide_df$accession)
wide_df$accession
# Extract individual ID from SampleName
samples_with_ids <- samples %>%
mutate(
accession   = str_extract(SampleName, "\\d{6}"),                # "005258"
replicate   = str_extract(SampleName, "(?<=\\d{6}_)\\d+(?=-)")  # "2" or NA
)
# Gather group assignments into long format
group_cols <- factor(c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12"),
levels = c("mother_P12", "mother_P28", "mother_B", "infant_B", "infant_M3",
"infant_M12", "BM_W2", "BM_M1", "BM_M2", "BM_M3", "BM_M6", "BM_M12"))
long_df <- samples_with_ids %>%
pivot_longer(all_of(group_cols),
names_to  = "group",
values_to = "in_group") %>%
filter(in_group == 1) %>%
select(accession, replicate, group, SampleName)
wide_df <- long_df %>%
pivot_wider(
id_cols      = c(accession, replicate),
names_from   = group,
values_from  = SampleName
) %>%
sort(wide_df$accession)
wide_df <- long_df %>%
pivot_wider(
id_cols      = c(accession, replicate),
names_from   = group,
values_from  = SampleName
)
wide_df
wide_df$accession
sort(as.numeric(wide_df$accession))
order(as.numeric(wide_df$accession))
wide_df[order(as.numeric(wide_df$accession)),]
write.csv(wide_df, "LLNext_ind_timepoints.csv", quote = FALSE)
wide_df <- wide_df[order(as.numeric(wide_df$accession)),]
write.csv(wide_df, "LLNext_ind_timepoints.csv", quote = FALSE)
